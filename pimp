#!/bin/sh

#                             :::::::::   +#+    :::   :::    :::::::::
#                (/;         :+:    :+:        :+:+: :+:+:   :+:    :+:
#         .--..-(/;         +:+    +:+  +:+  +:+ +:+:+ +:+  +:+    +:+
#         |    (/;         +#++:++#+   +#+  +#+  +:+  +#+  +#++:++#+
#       __|====/=|__      +#+         +#+  +#+       +#+  +#+
#      (____________)    #+#         #+#  #+#       #+#  #+#
#                       ###         ###  ###       ###  ###
#    
#                                             raspberry pi music player
#                                                       -- -     -
#
#  Copyright (c) 2022-2026 Steven Peguero (stevenpeguero.com)
#  Source is licensed under MIT License. Refer to LICENSE file for details.

param="$(printf '%s\n' "$*" | awk '{$1=""; print}' | sed 's/^[[:space:]]*//g')"

prereq_stop="pimp fzf mpv"
prereq_cont="espeak sox"

PIMP_DPATH_CACHE="${PIMP_DPATH_CACHE-"${HOME}/.cache/pimp"}"
PIMP_DPATH_CACHE_PLAY_POS="${PIMP_DPATH_CACHE_PLAY_POS-"${PIMP_DPATH_CACHE}/playback"}"
PIMP_DPATH_CONF="${PIMP_DPATH_CONF-"${HOME}/.config/pimp"}"
PIMP_DPATH_MUSIC="${PIMP_DPATH_MUSIC-"${HOME}/Music"}"
PIMP_FPATH_PLAYLIST="${PIMP_FPATH_PLAYLIST-"${PIMP_DPATH_CACHE}/playlist"}"

export PIMP_PROCESS=  #  exported environment variable that provides users with
                      #  the programmatic ability to host pimp-exclusive mpv
                      #  lua customizations via ${HOME}/.config/mpv/scripts.

opt()
{
	#  synopsis:  detects parameter options passed alongside a function call.
	#
	#  usage:
	#    opt a "${string}"
	#        ^
	#        |
	#        |
	#        "a" as in an "-a" option when calling a function.
	#
	#  below, a string / $2 ("a") must match specified option / $1 ("-a").

	if printf '%s' "$2" | grep -q "$1"
	then
		return 0  #  true
	else
		return 1  #  false
	fi
}

show_dname_filter()
{
	#  synopsis:  shows recursive and interactive list of directories to play.

	local opt="$(
		printf '%s' "$*"          | \
		grep -o '\-[a-zA-Z0-9]*'  | \
		sed 's/-//g'              | \
		tr -d '\n'
	)"

	local str="$(
		printf '%s' "$*"          | \
		sed 's/\-[a-zA-Z0-9]*//g' | \
		sed 's/^[[:space:]]*//g'  | \
		sed 's/[[:space:]]*$//g'
	)"

	if opt q "${opt}"
	then
		export opt_q='-q'
		local fzf_preview=
	else
		export opt_q=
		local fzf_preview='pimp app-speech {} && pimp app-tone high'

		if [ -n "${str}" ]
		then
			(play_tonal_sound high &)
		fi
	fi

	local dpath_music="${PIMP_DPATH_MUSIC}"

	set_term_title

	find -L "${dpath_music}" -type d | \
	cut -d '/' -f "$(print_cut_field_selection_number)" | sed '/^$/d' | sed '1i\
.
	' | sort -r | \
	fzf -i -s -m -e \
		--header 'pimp (dir)' \
		--header-first \
		--border rounded \
		--color fg+:0,bg+:10,hl:9,hl+:1,border:11,gutter:1,header:11,prompt:7,info:8,query:15 \
		--prompt '> ' \
		--algo v1 \
		--query "${str}" \
		--literal \
		--cycle \
		--tac \
		--layout reverse \
		--preview "${fzf_preview}" \
		--preview-window 0% \
		--bind 'enter:execute(pimp app-rmpp; pimp play -ds ${opt_q} {}; pimp app-tone high ${opt_q})' \
		--bind 'double-click:execute(pimp app-rmpp; pimp play -ds ${opt_q} {}; pimp app-tone high ${opt_q})' \
		--bind 'change:first' \
		--bind 'bspace:clear-query' \
		--bind 'home:first' \
		--bind 'end:last' \
		--bind 'esc:abort' \
		--bind 'tab:abort' \
		--bind 'insert:execute-silent(pimp app-tone ftgo ${opt_q})+execute(pimp file ${opt_q})+execute-silent(pimp app-tone ftbk ${opt_q})' \
		--bind 'alt-q:abort' \
		--bind 'ctrl-q:abort' \
		--bind 'f5:execute-silent(pimp app-tone ftgo ${opt_q})+execute(pimp file ${opt_q})+execute-silent(pimp app-tone ftbk ${opt_q})' \
		--bind 'f6:execute(pimp play ${opt_q}; pimp app-tone high ${opt_q})' \
		--bind '*:execute(pimp play ${opt_q}; pimp app-tone high ${opt_q})' \
		--bind "f7:reload(pimp dir ${opt_q})+abort"
}

show_fpath_filter()
{
	#  synopsis:  shows recursive and interactive list of files to play.

	local opt="$(
		printf '%s' "$*"          | \
		grep -o '\-[a-zA-Z0-9]*'  | \
		sed 's/-//g'              | \
		tr -d '\n'
	)"

	local str="$(
		printf '%s' "$*"          | \
		sed 's/\-[a-zA-Z0-9]*//g' | \
		sed 's/^[[:space:]]*//g'  | \
		sed 's/[[:space:]]*$//g'
	)"

	if opt q "${opt}"
	then
		export opt_q='-q'
	else
		export opt_q=
		(play_tonal_sound high &)
	fi

	local cmd_pimp_quit='10_cmd_filter_quit'
	local cmd_pimp_refresh='20_cmd_filter_refresh'
	local cmd_pimp_resume_playback='30_cmd_resume_playback'
	local dpath_music="${PIMP_DPATH_MUSIC}"
	local fpath_playlist="${PIMP_FPATH_PLAYLIST}"
	local i=0
	local int_modtime_plist_preloop="$(get_file_modtime "${fpath_playlist}")"
	local int_modtime_plist_postloop=

	set_term_title

	find -L "${dpath_music}" -type f | \
	cut -d '/' -f "$(print_cut_field_selection_number)" | sed '/^$/d' | sort -r | \
	fzf -i -s -m -e \
		--header 'pimp (file)' \
		--header-first \
		--border rounded \
		--color fg+:0,bg+:10,hl:9,hl+:1,border:11,gutter:12,header:11,prompt:7,info:8,query:15 \
		--prompt '> ' \
		--algo v1 \
		--query "${str}" \
		--literal \
		--cycle \
		--tac \
		--header-lines 0 \
		--layout reverse \
		--bind 'enter:select-all+accept' \
		--bind 'double-click:select-all+accept' \
		--bind 'change:first' \
		--bind 'backward-eof:execute-silent(pimp app-tone clsh ${opt_q})' \
		--bind 'alt-bspace:clear-query' \
		--bind 'home:first' \
		--bind 'end:last' \
		--bind "esc:become(printf '%s\n'    ${cmd_pimp_quit})+abort" \
		--bind "tab:become(printf '%s\n'    ${cmd_pimp_quit})+abort" \
		--bind "insert:become(printf '%s\n' ${cmd_pimp_quit})+abort" \
		--bind "alt-q:become(printf '%s\n'  ${cmd_pimp_quit})+abort" \
		--bind "ctrl-q:become(printf '%s\n' ${cmd_pimp_quit})+abort" \
		--bind "f5:become(printf '%s\n'     ${cmd_pimp_quit})+abort" \
		--bind "f6:become(printf '%s\n'     ${cmd_pimp_resume_playback})+abort" \
		--bind "*:become(printf '%s\n'      ${cmd_pimp_resume_playback})+abort" \
		--bind "f7:become(printf '%s\n'     ${cmd_pimp_refresh})+abort" | ( \

		#  until `fzf` intuitively enables the processing of multi-line
		#  output, a while-read subshell, along with case and return
		#  statements, must be facilitated to mimic said program as it
		#  would normally behave (when handling single-line output).

		while read -r f
		do
			if [ ${i} -eq 0 ]
			then
				case "${f}" in
					"${cmd_pimp_quit}")
						return 10
						;;
					"${cmd_pimp_refresh}")
						return 20
						;;
					"${cmd_pimp_resume_playback}")
						return 30
						;;
					*)
						rm -f "${fpath_playlist}"
						;;
				esac
			fi

			if [ ${i} -eq 200 ]  #  if 200th playlist item is processed (indicating playback delay).
			then
				play_tonal_sound ffpi "${opt_q}"
			fi

			#  create absolute path and add to playlist file:
			printf '%s/%s\n' "${dpath_music}" "${f}" >> "${fpath_playlist}"
			i=$((${i}+1))

			continue
		done

		return 0
	)

	case "$?" in
		10)
			return 0
			;;
		20)
			return 100
			;;
		30)
			play_music "${opt_q}"
			return 100
			;;
		*)
			int_modtime_plist_postloop="$(get_file_modtime "${fpath_playlist}")"

			if [ "${int_modtime_plist_postloop}" != "${int_modtime_plist_preloop}" ]
			then
				remove_playback_position_cache
				play_music -s "${opt_q}"
				return 100
			else
				return 0
			fi
	esac
}

play_music()
{
	#  synopsis:  plays contents of generated playlist file.

	local opt="$(
		printf '%s' "$*"          | \
		grep -o '\-[a-zA-Z0-9]*'  | \
		sed 's/-//g'              | \
		tr -d '\n'
	)"

	local str="$(
		printf '%s' "$*"          | \
		sed 's/\-[a-zA-Z0-9]*//g' | \
		sed 's/^[[:space:]]*//g'  | \
		sed 's/[[:space:]]*$//g'
	)"

	local sys="$(uname -s | tr '[:upper:]' '[:lower:]')"

	local dpath_cache="${PIMP_DPATH_CACHE}"
	local dpath_conf="${PIMP_DPATH_CONF}"
	local dpath_cache_playback_position="${PIMP_DPATH_CACHE_PLAY_POS}"
	local dpath_music="${PIMP_DPATH_MUSIC}"
	local dpath_filter_selection=
	local fpath_playback_input_conf="${dpath_conf}/input.conf"
	local fpath_playback_position_autosave_script="${dpath_cache}/autosave.lua"
	local fpath_playlist="${PIMP_FPATH_PLAYLIST}"

	#  terminate speech and respective tonal sound upon music selection.

	pkill -x espeak &
	clear

	if opt d "${opt}" && [ -n "${str}" ]
	then
		#  create playlist file using dname_filter selection.

		if [ -d "${dpath_music}/${str}" ]
		then
			dpath_filter_selection="$(realpath "${dpath_music}/${str}")"
			find -L "${dpath_filter_selection}" -type f > "${fpath_playlist}"
		else
			return 1
		fi
	fi

	if ! [ -f "${fpath_playback_position_autosave_script}" ]
	then
		if ! print_playback_position_autosave_script > "${fpath_playback_position_autosave_script}"
		then
			printf 'pimp: unable to create playback position auto-save script: %s\n' "${fpath_playback_position_autosave_script}" >&2
		fi
	fi

	if ! [ -f "${fpath_playback_input_conf}" ]
	then
		if ! touch "${fpath_playback_input_conf}"
		then
			printf 'pimp: unable to create playback input configuration file: %s\n' "${fpath_playback_input_conf}" >&2
		fi
	fi

	if [ -f "${fpath_playlist}" ]
	then

		if opt s "${opt}"
		then
			#  shuffle cached playlist file content.
			sort -R "${fpath_playlist}" -o "${fpath_playlist}"
		fi

		case "${sys}" in
			darwin|linux)
				printf '%spimp: initiating the slap... (⌐■_■)%s\n' \
					"$(tput bold)" "$(tput sgr0)"
				;;
			*)
				printf '%spimp: initiating the slap... %s\n' \
					"$(tput bold)" "$(tput sgr0)"
				;;
		esac
		
		if opt q "${opt}"
		then
			continue
		else
			play_tonal_sound play
		fi

		mpv \
			--af-add=scaletempo=speed=both \
			--audio-pitch-correction=no \
			--display-tags= \
			--input-conf="${fpath_playback_input_conf}" \
			--loop-playlist=inf \
			--msg-level=all=no,term-msg=status,statusline=status,cplayer=error,ffmpeg=fatal,ffmpeg/demuxer=error \
			--no-audio-display \
			--no-video \
			--osd-level=0 \
			--playlist="${fpath_playlist}" \
			--save-position-on-quit \
			--script="${fpath_playback_position_autosave_script}" \
			--term-playing-msg="\n\${filename}" \
			--term-status-msg="\n\${time-pos} / \${duration} (\${percent-pos}%) (x\${speed}) \${?loop-file==inf:+LF }\${?mute==yes:+M }\${?pause==yes:(Paused)}" \
			--term-title="pimp -- \${filename}" \
			--vo=null \
			--volume-max=100 \
			--video=no \
			--watch-later-directory="${dpath_cache_playback_position}" \
			--watch-later-options=volume,speed,pause,loop-file,start \
			--watch-later-options-remove=mute,ab-loop

		set_term_title
	else
		printf 'pimp: playlist file not found: %s\n' "${fpath_playlist}" >&2
		return 2
	fi
}

check_prerequisites()
{
	#  synopsis:  ensures program prerequisites exist in ${PATH}.

	local err=0
	local i=               #   last program will not process without
	local programs="$* -"  # < placeholder at end of string.

	printf '%s' "${programs}" | tr '[:space:]' '\n' | ( \

		while read -r i
		do
			if ! command -v "${i}" >/dev/null 2>&1
			then
				if [ ${err} -eq 0 ]
				then
					printf 'pimp: prerequisite programs not found in $PATH:\n' >&2
					err=1
				fi
				
				printf '%s\n' " - ${i}" >&2
			fi
		done

		return "${err}"
	)

	return $?
}

create_program_dirs()
{
	#  synopsis:  create program directories.

	local dpath_cache="${PIMP_DPATH_CACHE}"
	local dpath_conf="${PIMP_DPATH_CONF}"
	local dpath_cache_playback_position="${PIMP_DPATH_CACHE_PLAY_POS}"

	if ! [ -d "${dpath_cache}" ]
	then
		if ! mkdir -p "${dpath_cache}"
		then
			printf 'pimp: unable to create cache directory: %s\n' "${dpath_cache}" >&2
			return 2
		fi
	fi

	if ! [ -d "${dpath_conf}" ]
	then
		if ! mkdir -p "${dpath_conf}"
		then
			printf 'pimp: unable to create config directory: %s\n' "${dpath_conf}" >&2
		fi
	fi

	if ! [ -d "${dpath_cache_playback_position}" ]
	then
		if ! mkdir -p "${dpath_cache_playback_position}"
		then
			printf 'pimp: unable to create playback position directory: %s\n' "${dpath_cache_playback_position}" >&2
		fi
	fi

	return 0
}

get_file_modtime()
{
	#  synopsis:  gets modified epoch timestamp of file.

	local f="$1"
	local modtime=
	local sys="$(uname -s | tr '[:upper:]' '[:lower:]')"

	if ! [ -f "${f}" ]
	then
		printf 0
		return 1
	fi

	case "${sys}" in
		linux)
			modtime="$(stat -c %Y "${f}")"
			printf '%s' "${modtime}"
			;;
		openbsd|*)
			modtime="$(stat -f %m "${f}")"
			printf '%s' "${modtime}"
			;;
	esac

	return 0
}

play_tonal_sound()
{
	#  synopsis:  plays tonals sounds for auditory navigation.

	local opt="$(
		printf '%s' "$*"          | \
		grep -o '\-[a-zA-Z0-9]*'  | \
		sed 's/-//g'              | \
		tr -d '\n'
	)"

	local str="$(
		printf '%s' "$*"          | \
		sed 's/\-[a-zA-Z0-9]*//g' | \
		sed 's/^[[:space:]]*//g'  | \
		sed 's/[[:space:]]*$//g'
	)"

	if opt q "${opt}"
	then
		return 0
	fi

	if ! command -v sox >/dev/null 2>&1
	then
		return 1
	fi

	case "${str}" in
		clsh)
			#  text (search box cleared)
			play -qn synth sine 0200 trim 0 0.05 gain -20
			;;
		ffpi)
			#  fpath_filter playlist initialization
			play -qn synth sine 0500 trim 0 0.05 gain -20
			;;
		ftbk)
			#  filter (return to dname_filter)
			play -qn synth sine 1500 trim 0 0.05 gain -30
			play -qn synth sine 1400 trim 0 0.05 gain -30
			;;
		ftgo)
			#  filter (change to fpath_filter)
			play -qn synth sine 1500 trim 0 0.05 gain -30
			;;
		high)
			#  item (highlighted)
			play -qn synth sine 2000 trim 0 0.05 gain -30
			;;
		play)
			#  item (selected for music playback)
			play -qn synth sine 1000 trim 0 0.05 gain -30
			;;
	esac

	return 0
}

play_speech()
{
	#  synopsis:  plays speech for auditory navigation.

	local opt="$(
		printf '%s' "$*"          | \
		grep -o '\-[a-zA-Z0-9]*'  | \
		sed 's/-//g'              | \
		tr -d '\n'
	)"

	local str="$(
		printf '%s' "$*"          | \
		sed 's/\-[a-zA-Z0-9]*//g' | \
		sed 's/^[[:space:]]*//g'  | \
		sed 's/[[:space:]]*$//g'
	)"

	local sys="$(uname -s | tr '[:upper:]' '[:lower:]')"

	if opt q "${opt}"
	then
		return 0
	fi

	if ! command -v espeak >/dev/null 2>&1
	then
		return 1
	fi

	case "${sys}" in
		linux)
			printf '%s' "${str}" | sed 's/\//, /g' | espeak -a 100 -s 300 || return 1
			;;
		*)
			printf '%s' "${str}" | sed 's/\//, /g' | espeak -a 100 -s 235 || return 1
			;;
	esac
}

print_cut_field_selection_number()
{
	#  description:
	#
	#  posix solution to count number of directory levels in
	#  ${PIMP_DPATH_MUSIC}; facilitates removal of ${PIMP_DPATH_MUSIC}
	#  from filter lists via `cut`.

	local dpath_music="${PIMP_DPATH_MUSIC}"
	local int_dpath_sections="$(( $(printf '%s' "${dpath_music}" | sed 's/\// /g' | wc -w) + 2 ))"

	printf '%s-' "${int_dpath_sections}" && \
		return 0
}

print_playback_position_autosave_script()
{
	cat <<EOF

-- autosave.lua
-- ------------
-- 
-- periodically saves watch_later data during mpv playback.
-- accounts for periodic cached write synchronization on raspberry pi.

os        = require 'os'
mp        = require 'mp'
mp_opt    = require 'mp.options'
timer_opt = {save_period = 15} -- seconds per mpv watch_later cache save.
raspi     = false

function platform()

	-- gets running platform / os.

	local out = io.popen('uname -s')
	local sys = out:read '*line'

	io.close(out)
	return sys:lower()
end

function raspi_write_sync()

	-- synchronizes watch_later cache to raspberry pi storage device.

	local f = nil

	if raspi == true then
		os.execute('sync')
		return true
	end

	-- raspberry pi os:
	if platform() == 'linux' then
		f = io.open('/sys/firmware/devicetree/base/model', 'r')
	end

	if f ~= nil then
		str = f:read '*a'
		io.close(f)
	else
		return false
	end

	if string.match(str, '^Raspberry Pi') then
		raspi = true
		os.execute('sync')
		return true
	else
		return false
	end
end

function add_wl()
	mp.commandv('write-watch-later-config')
	raspi_write_sync()
end

function del_wl(data)
	if data.reason == 'eof' or data.reason == 'stop' then
		local playlist = mp.get_property_native('playlist')
		
		for i, entry in pairs(playlist) do
			if entry.id == data.playlist_entry_id then
				mp.commandv('delete-watch-later-config', entry.filename)
				raspi_write_sync()
			end
		end
	end
end

mp_opt.read_options(timer_opt)
save_period_timer = mp.add_periodic_timer(timer_opt.save_period, add_wl)

mp.register_event('file-loaded', add_wl)
mp.register_event('start-file',  add_wl)
mp.register_event('end-file',    del_wl)
EOF

	return 0
}

print_usage()
{
	#  synopsis:  prints usage information.  

	print_funny_usage_header()
	{
		int=$(awk -v min=0 -v max=4 '
			BEGIN{srand()
			print int(min+rand()*(max-min+1))
		}')
		
		case "$int" in
			0)
				printf "Show that stereo who's boss."
				;;
			1)
				printf 'Whatsup, playa!?'
				;;
			2)
				printf 'Put that stereo in its place.'
				;;
			3)
				printf 'Unleash the slap.'
				;;
			4)
				printf 'Make the whole hood jealous.'
				;;
		esac
	}

	cat <<EOF
$(print_funny_usage_header)

usage:
  pimp [d|dir] [-q] [query]
  pimp [f|file] [-q] [query]
  pimp [p|play|slap] [-dqs] [path]

  pimp [app-rmpp]
  pimp [app-speech] [-q] text
  pimp [app-tone] [-q] clsh|ffpi|ftbk|ftgo|high|play

commands:
  d, dir [-q] [query]            List directories in fuzzy finder.
  f, file [-q] [query]           List files in fuzzy finder.
  p, play, slap [-dqs] [path]    Resume music playback.

commands (not intended for user invocation):
  app-rmpp                                       Delete playback position cache.
  app-speech [-q] text                           Play text-to-speech.
  app-tone [-q] clsh|ffpi|ftbk|ftgo|high|play    Play tonal sound.

options:
  -d [path]    Play relative directory path (case-sensitive).
  -q           Suppress all auditory navigation.
  -s           Shuffle cached playlist file content.

examples:
  pimp slap                 Resume the slap (music playback).
  pimp d deep house         Search for directory containing "deep house" string.
  pimp f mixes/ fm 199      Search for files containing "fm" and "199" with
                            paths that match the "mixes/" string.
  pimp p -d hip hop/lofi    Play "hip hop/lofi" path without using fuzzy finder.
EOF

	return 1
}

remove_playback_position_cache()
{
	#  synopsis:  deletes cached mpv watch_later / playback position data.

	set -u

	local dpath_cache_playback_position="${PIMP_DPATH_CACHE_PLAY_POS}"

	if rm -f "${dpath_cache_playback_position}"/* >/dev/null 2>&1
	then
		return 0
	else
		printf 'pimp: playback cache files stored within "%s" could not be deleted.\n' \
			"${dpath_cache_playback_position}" >&2
		return 1
	fi
}

set_term_title()
{
	printf "\033]0;pimp\007"  
}

if ! check_prerequisites "${prereq_stop}"
then
	exit 2
fi

if ! check_prerequisites "${prereq_cont}"
then
	printf '\npimp: continuing...\n' >&2
fi

if ! create_program_dirs
then
	exit 2
fi

if ! [ -d "${PIMP_DPATH_MUSIC}" ]
then
	printf 'pimp: music directory not found: %s\n' "${PIMP_DPATH_MUSIC}" >&2
	exit 2
fi

case "$1" in
	d|dir)
		show_dname_filter "${param}"
		exit $?
		;;
	f|file)
		while :
		do
			show_fpath_filter "${param}"

			case "$?" in
				100)
					continue
					;;
				*)
					exit $?
					;;
			esac
		done
		;;
	h|-h|--help|help)
		print_usage
		exit $?
		;;
	p|play|slap)
		play_music "${param}"
		exit $?
		;;
	app-tone)
		play_tonal_sound "${param}"
		exit $?
		;;
	app-speech)
		play_speech "${param}"
		exit $?
		;;
	app-rmpp)
		remove_playback_position_cache
		exit $?
		;;
	*)
		if [ -f "${PIMP_FPATH_PLAYLIST}" ]
		then
			play_music "${param}"
		fi

		show_dname_filter "${param}"
		exit $?
		;;
esac
